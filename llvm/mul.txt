declare { i$(bit), i1 } @llvm.usub.with.overflow.i$(bit)(i$(bit) %x, i$(bit) %y)

define i$(unit) @extract$(bit+unit)(i$(bit+unit) %x, i$(bit+unit) %shift) {
	%t0 = lshr i$(bit+unit) %x, %shift
	%t1 = trunc i$(bit+unit) %t0 to i$(unit)
	ret i$(unit) %t1
}
define i$(unit) @extractLow$(unit)(i$(unit*2) %x) {
	%t0 = lshr i$(unit*2) %x, $(unit)
	%t1 = trunc i$(unit*2) %t0 to i$(unit)
	ret i$(unit) %t1
}
define i$(unit*2) @mul$(unit)x$(unit)(i$(unit) %x, i$(unit) %y) {
	%x0 = zext i$(unit) %x to i$(unit*2)
	%y0 = zext i$(unit) %y to i$(unit*2)
	%z = mul i$(unit*2) %x0, %y0
	ret i$(unit*2) %z
}

define i64 @mulp32x32(i32 *%px, i32 %y, i32 %i)
{
	%p = getelementptr i32* %px, i32 %i
	%x = load i32* %p
	%xy = call i64 @mul32x32(i32 %x, i32 %y)
	ret i64 %xy
}

define void @storePos$(unit)(i$(unit) *%p, i$(unit) %v, i$(unit) %i)
{
	%pp = getelementptr i$(unit) *%p, i$(unit) %i
	store i$(unit) %v, i$(unit)* %pp
	ret void
}

@define u2 = unit*2
define void @Xmul128x32(i32 *%pz, i32 *%px, i32 %y)
{
@for i, 0, N
	%x$(i)y = call i$(u2) @mulp$(unit)x$(unit)(i$(unit) *%px, i$(unit) %y, i$(unit) $(i))
	%L$(i) = trunc i$(u2) %x$(i)y to i$(unit)
	%H$(i) = call i$(unit) @extractLow$(unit)(i$(u2) %x$(i)y)
	call void @storePos$(unit)(i$(unit) *%pz, i$(unit) %L$(i), i$(unit) $(i))
@endfor

	%L1e = zext i32 %L1 to i128
	%L2e = zext i32 %L2 to i128
	%L3e = zext i32 %L3 to i128
	%L2es = shl i128 %L2e, 32
	%L3es = shl i128 %L3e, 64
	%Lt0 = or i128 %L1e, %L2es
	%Lt1 = or i128 %Lt0, %L3es

	%H0e = zext i32 %H0 to i128
	%H1e = zext i32 %H1 to i128
	%H2e = zext i32 %H2 to i128
	%H3e = zext i32 %H3 to i128
	%H1es = shl i128 %H1e, 32
	%H2es = shl i128 %H2e, 64
	%H3es = shl i128 %H3e, 96
	%Ht0 = or i128 %H0e, %H1es
	%Ht1 = or i128 %Ht0, %H2es
	%Ht2 = or i128 %Ht1, %H3es
	%t = add i128 %Ht2, %Lt1

	%pz1 = getelementptr i32* %pz, i32 1
	%pz2 = bitcast i32* %pz1 to i128*

	store i128 %t, i128* %pz2
	
	ret void
}
